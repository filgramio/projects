<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Minimal Web Page</title>
</head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(window.innerWidth-15, window.innerHeight-15); 
      frameRate(60);
        
      var levelMap = [
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
      [0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
      [0,0,0,0,1,1,1,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1],
      [0,0,0,0,1,0,1,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
      [0,0,0,3,0,3,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,3,3,3,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,3,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,3,3,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];

      var isSolid = function(n){
        switch(n) {
          case 0:
            return false;
          case 1:
            return true;
          case 2:
            return true;
          case 3:
            return true;
          default:
            return false;
        }
      }
      var collisionTiles = function(x,y){
        var tiles = [];
        fill(255, 0, 0, 100);
        if(x > 15 && x < levelMap[0].length * 40-15 && y > 15 && y < levelMap.length * 40-15) {
          tiles.push(levelMap[floor((y-15)/40)][floor((x-15)/40)]);
          //rect(floor((x-15)/40) * 40,floor((y-15)/40) * 40, 40, 40);  
          tiles.push(levelMap[floor((y-15)/40)][floor((x+15)/40)]);
          //rect(floor((x+15)/40) * 40,floor((y-15)/40) * 40, 40, 40);  
          tiles.push(levelMap[floor((y+15)/40)][floor((x-15)/40)]);
          //rect(floor((x-15)/40) * 40,floor((y+15)/40) * 40, 40, 40);  
          tiles.push(levelMap[floor((y+15)/40)][floor((x+15)/40)]);
          //rect(floor((x+15)/40) * 40,floor((y+15)/40) * 40, 40, 40);              
        }else{
          return [1,1,1,1];
        }
        return tiles;
      };
      var hasCollision = function(x, y) {
        var tiles = collisionTiles(x, y);
        for (var i = 0; i < tiles.length; i++) {
          if (isSolid(tiles[i])) {
            return true;
          }
        }
        return false;
      };

      var x = 100;
      var y = 100;

      var movable = true;

      var keys = [];
      keyPressed = function() {
        keys[keyCode] = true;
      };
      keyReleased = function() {
        keys[keyCode] = false;
      };

      var mouseIsPressed = false;
      var startMouseX = 0;
      var startMouseY = 0;

      var cameraX = width/2;
      var cameraY = height/2;
      var cameraZoom = 1;
      
      var sunAngle = 1;

      mousePressed = function() {
        mouseIsPressed = true;
        startMouseX = mouseX;
        startMouseY = mouseY;
      };
      mouseReleased = function() {
        mouseIsPressed = false;
      };

      var playerImage = loadImage("images/player.png");

      imageMode(CENTER);
      draw = function() {
        background(255);
        pushMatrix();
        translate(-cameraX+width/2, -cameraY+height/2);
        for (var i = levelMap.length-1; i > -1; i--) {
          for (var j = levelMap[i].length-1; j > -1; j--) {
            noStroke();
            switch (levelMap[i][j]) {
              case 0:
                fill(50,205,50);
                rect(j * 40, i * 40, 40, 40);
              break;
              case 1:
                fill(150);
                rect(j * 40, i * 40, 40, 40);
                fill(200);
                rect(j * 40, i * 40, 40, 20);
                if (i < levelMap.length-1 && levelMap[i+1][j] == 1) {
                  fill(200);
                  rect(j * 40, i * 40, 40, 40);
                }
                if(j < levelMap[0].length-1 && levelMap[i][j+1] == 0) {
                  fill(100,100,100,180);
                  translate(j * 40, i * 40);
                  quad(40,0,40,40,50,40,50,10);
                  if(j < levelMap[0].length-1 && i < levelMap.length-1 && levelMap[i+1][j+1] == 0){
                    triangle(40,40,50,40,50,50);
                  }
                  translate(-j * 40, -i * 40);                   
                }
                if(i < levelMap.length-1 && levelMap[i+1][j] == 0) {
                  fill(100,100,100,180);
                  translate(j * 40, i * 40);
                  quad(0,40,40,40,40,50,10,50);
                  if(j < levelMap[0].length-1 && i < levelMap.length-1 && levelMap[i+1][j+1] == 0){
                    triangle(40,40,40,50,50,50);
                  }
                  translate(-j * 40, -i * 40);                   
                }
              break;
              case 2:
                fill(50,205,50);
                rect(j * 40, i * 40, 40, 40);          
                pushMatrix();
                translate(j * 40, i * 40);
                fill(100,100,100,180);
                ellipse(25,38,16,16);
                fill(101,67,33);      
                ellipse(20,35,6,6);
                rect(17,20,6,15);
                fill(34,139,34);  
                ellipse(20,17,26,26);
                popMatrix();
              break;
              case 3:
                fill(50, 205, 50);
                rect(j * 40, i * 40, 40, 40);
                pushMatrix();
                translate(j * 40, i * 40);
                fill(0,191,255);
                rect(0,0,40,40,5);
                var u = false;
                var d = false;
                var l = false;
                var r = false;
                if(j < levelMap[0].length-1 && levelMap[i][j+1] == 3){
                  r = true;
                }
                if(j > 0 && levelMap[i][j-1] == 3){
                  l = true;
                }
                if(i < levelMap.length-1 && levelMap[i+1][j] == 3){
                  d = true;
                }
                if(i > 0 && levelMap[i-1][j] == 3){
                  u = true;
                }
                if(r || d){
                  fill(0,191,255);
                  rect(35,35,5,5);
                }
                if(r || u){
                  fill(0,191,255);
                  rect(35,0,5,5);
                }
                if(l || u){
                  fill(0,191,255);
                  rect(0,0,5,5);
                }
                if(l || d){
                  fill(0,191,255);
                  rect(0,35,5,5);
                }


                popMatrix();
              break;
            }
          }
        }

        //Draw the player
        image(playerImage, x, y);

        //Camera movement
        if (mouseIsPressed && mouseButton == LEFT) {
          var deltaX = mouseX - startMouseX;
          var deltaY = mouseY - startMouseY;
          if(width < levelMap[0].length * 40) {
            cameraX -= deltaX;
          }
          if(height < levelMap.length * 40) {
            cameraY -= deltaY;
          }
          startMouseX = mouseX;
          startMouseY = mouseY;
        }
        if(width < levelMap[0].length * 40) {
          cameraX = constrain(cameraX,width/2,levelMap[0].length * 40 - width/2);
        }
        if(height < levelMap.length * 40) {
          cameraY = constrain(cameraY,height/2,levelMap.length * 40 - height/2);
        }
        //println("Camera Position: (" + cameraX + ", " + cameraY + ")");
        
        //movement
        if (movable) {
          if(keys[LEFT] && !hasCollision(x-3, y)) {
            x -= 4
          }
          if(keys[RIGHT] && !hasCollision(x+3, y)) {
            x += 4
          }
          if(keys[UP] && !hasCollision(x, y-3)) {
            y -= 4
          }
          if(keys[DOWN] && !hasCollision(x, y+3)) {
            y += 4
          }
        }

        popMatrix();
      };


    }};

  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>