<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Slide It Editor</title>

    <style>
      /* center canvas horizontally and vertically */
      html, body { height: 100%; margin: 0; }
      body {
        display: flex;
        align-items: center;      /* vertical center */
        justify-content: center;  /* horizontal center */
        background: #1e122c;         /* optional */
      }
      /* keep canvas responsive */
      canvas#mycanvas {
        display: block;
        max-width: 100%;
        height: auto;
      }
    </style>
</head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var mouseLeftCanvas = false;
  var canvas = document.getElementById("mycanvas");
  
  canvas.addEventListener('mouseleave', function() {
    mouseLeftCanvas = true;
  });
  
  canvas.addEventListener('mouseenter', function() {
    mouseLeftCanvas = false;
  });

  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(400, 600); 
      frameRate(60);
      strokeWeight(4);
        
      // Paste code from Khan Academy here:

      mouseIsPressed = false;
      mousePressed = function(){
        mouseIsPressed = true;
      };
      mouseReleased = function(){
        mouseIsPressed = false;
      };

      var Level = function(name, area, speed, bgCol, blockCol, channelColors){
        this.name = name;
        this.area = area; // array of arrays from top left // 1 = block, 0 = empty, or an object
        this.speed = speed;
        this.scrolled = 0;
        this.bgCol = bgCol;
        this.blockCol = blockCol;
        this.channelColors = channelColors; // map from channel number to color
        this.channels = [false,false,false,false,false,false,false,false,false,false];
      }

      var Button = function(channel,clicks){
        this.type = "button";
        this.channel = channel;
        this.clicks = clicks;
        this.remaining = clicks;
      };

      var Door = function(channel,invert){
        this.type = "door";
        this.channel = channel;
        this.invert = invert || false;
      };

      Level.prototype.draw = function(){
        pushMatrix();
        translate(0, this.scrolled);
        background(this.bgCol);
        for(var i=0; i<this.area.length; i++){
          for(var j=0; j<this.area[i].length; j++){
            var cell = this.area[i][j];
            switch(cell){
              case 0:
                // empty
                break;
              case 1:
                // block
                fill(this.blockCol);
                noStroke();
                rect(j*40, i*40 - this.area.length*40 + height, 40, 40); //draw it aligned bottom to bottom
                stroke(50);
                if(j>0 && this.area[i][j-1] !== 1){
                  line(j*40, i*40 - this.area.length*40 + height, j*40, i*40 - this.area.length*40 + height +40);
                }
                if(j<this.area[i].length-1 && this.area[i][j+1] !== 1){
                  line(j*40+40, i*40 - this.area.length*40 + height, j*40+40, i*40 - this.area.length*40 + height +40);
                }
              if((i<this.area.length-1 && this.area[i+1][j] !== 1) || i === this.area.length-1){
                  line(j*40, i*40+40 - this.area.length*40 + height, j*40+40, i*40+40 - this.area.length*40 + height);
                }
                if(i>0 && this.area[i-1][j] !== 1){
                  line(j*40, i*40 - this.area.length*40 + height, j*40+40, i*40 - this.area.length*40 + height);
                }
              break;
              default:
                switch(cell.type){
                  case "button":
                    stroke(50);
                    fill(this.channelColors[cell.channel-1]);
                    ellipse(j*40+20, i*40 - this.area.length*40 + height +20, 30,30);
                    if(cell.remaining > 1){
                      fill(255-red(this.channelColors[cell.channel-1]),255-green(this.channelColors[cell.channel-1]),255-blue(this.channelColors[cell.channel-1]));
                      textAlign(CENTER, CENTER);
                      text(cell.remaining, j*40+20, i*40 - this.area.length*40 + height +20);
                    }
                  break;
                  case "door":
                    var doorCol = this.channelColors[cell.channel-1] || this.channelColors[cell.channel];
                    if(this.channels[cell.channel] !== cell.invert){
                      // open door
                      noStroke();
                      fill(doorCol,100);
                      rect(j*40, i*40 - this.area.length*40 + height, 40, 40);
                      break;
                    }
                    noStroke();                    
                    fill(doorCol);
                    rect(j*40, i*40 - this.area.length*40 + height, 40, 40);
                    stroke(50);

                    // Draw borders except where adjacent doors exist
                    if(j>0 && (this.area[i][j-1] === undefined || this.area[i][j-1].type !== "door")){
                      line(j*40, i*40 - this.area.length*40 + height, j*40, i*40 - this.area.length*40 + height +40);
                    }
                    if(j<this.area[i].length-1 && (this.area[i][j+1] === undefined || this.area[i][j+1].type !== "door")){
                      line(j*40+40, i*40 - this.area.length*40 + height, j*40+40, i*40 - this.area.length*40 + height +40);
                    }
                    if(i>0 && (this.area[i-1][j] === undefined || this.area[i-1][j].type !== "door")){
                      line(j*40, i*40 - this.area.length*40 + height, j*40+40, i*40 - this.area.length*40 + height);
                    }
                    if(i<this.area.length-1 && (this.area[i+1][j] === undefined || this.area[i+1][j].type !== "door")){
                      line(j*40, i*40+40 - this.area.length*40 + height, j*40+40, i*40+40 - this.area.length*40 + height);
                    }
                  break;
                }
            }

            if(i === gridMouseY && j === gridMouseX){
              noFill();
              stroke(255,0,0);
              rect(j*40, i*40 - this.area.length*40 + height, 40, 40);
            }
          }

        } 
        stroke(0,255,0);
        line(0,-this.area.length*40 + height,400,-this.area.length*40 + height);
        popMatrix();
      };
      Level.prototype.update = function(){
        this.doneScrolling = true;
        this.scrolled += this.speed;
      };
      Level.prototype.restrainScroll = function(){
        this.scrolled = floor(constrain(this.scrolled, 0,this.area.length*40 - height+40));
      };

      var pickedObject = 1;
      var editorInventory = [1, 0, new Button(1,1), new Door(1)];

      var a = new Button(1,1);
      var A = new Door(1);
      var b = new Button(2,5);
      var B = new Door(2);
      var editedLevel = new Level("The first",[        
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,1,0,0,0,0,0,0,0,0],
        [1,0,0,0,0,0,0,0,0,0],
        [0,1,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0]],2, color(230,230,230),color(100,100,255),[color(255,100,100),color(100,255,0)]);

      var currentLevel = editedLevel;
      // expose the current level object to the outside via processingInstance
      // so outer scripts can modify properties like `scrolled`.
      processingInstance.currentLevel = currentLevel;

      // Export level to JSON string (portable for other games)
      processingInstance.exportLevelString = function(){
        var area = currentLevel.area.map(function(row){
          return row.map(function(cell){
            if(cell === 0 || cell === 1) return cell;
            if(cell.type === "button"){
              return {t: "button", ch: cell.channel, cl: cell.clicks};
            }
            if(cell.type === "door"){
              return {t: "door", ch: cell.channel, inv: cell.invert};
            }
            return cell;
          });
        });
        var exported = {
          name: currentLevel.name,
          area: area,
          speed: currentLevel.speed,
          bgCol: [red(currentLevel.bgCol), green(currentLevel.bgCol), blue(currentLevel.bgCol)],
          blockCol: [red(currentLevel.blockCol), green(currentLevel.blockCol), blue(currentLevel.blockCol)],
          channelColors: currentLevel.channelColors.map(function(c){
            return [red(c), green(c), blue(c)];
          })
        };
        return JSON.stringify(exported);
      };

      // Download level string as .txt file
      processingInstance.downloadLevelString = function(){
        var str = processingInstance.exportLevelString();
        var blob = new Blob([str], {type: 'text/plain'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = (currentLevel.name || 'level') + '.txt';
        a.click();
        URL.revokeObjectURL(url);
      };

      var gridMouseX = 0;
      var gridMouseY = 0;
      var playing = false;

      {/*var checkDeathCollision = function(){
        // Check if mouse left the canvas
        if(mouseLeftCanvas){
          return true;
        }
        
        if(gridMouseX >= 0 && gridMouseX < currentLevel.area[0].length && gridMouseY >=0 && gridMouseY < currentLevel.area.length){
          var cell = currentLevel.area[gridMouseY][gridMouseX];
          switch(cell){
            case 0:
              return false;
            case 1:
              return true;
            default:
              switch(cell.type){
                case "button":
                  return false;
                case "door":
                  return currentLevel.channels[cell.channel] === cell.invert;
              }
          }
        }else{
          if(gridMouseY >= currentLevel.area.length || gridMouseY < 0){
            return false;
          }
          return true;
        }
      };
      */

      /*var checkButtonClick = function(){
        if(gridMouseX >= 0 && gridMouseX < currentLevel.area[0].length && gridMouseY >=0 && gridMouseY < currentLevel.area.length){
          var cell = currentLevel.area[gridMouseY][gridMouseX];
          if(cell.type === "button"){
            if(cell.remaining > 0){
              cell.remaining -= 1;
              if(cell.remaining === 0){
                currentLevel.channels[cell.channel] = true;
              }
            }
          }
        }
      };*/

      /*var checkWin = function(){
        if(mouseY < currentLevel.scrolled - currentLevel.area.length*40 + height){
          return true;
        }
      };*/

      /*mousePressed = function(){
        if(mouseY > height - 120){
          playing = true;
        }
        checkButtonClick();
      }*/}


      draw = function(){
        gridMouseX = floor(mouseX/40);
        gridMouseY = floor((mouseY - currentLevel.scrolled - height)/40 + currentLevel.area.length);
        background(255);
        currentLevel.draw();
        currentLevel.restrainScroll();
        if(playing){
          currentLevel.update();
        }
        if(mouseIsPressed && !mouseLeftCanvas && mouseY > 40){
          currentLevel.area[gridMouseY][gridMouseX] = pickedObject;
        }
        // Draw inventory bar at top
        noStroke();
        fill(0,0,0,50);
        rect(0, 0, 400, 40);
        for(var i = 0; i < editorInventory.length; i++){
          stroke(0);
          strokeWeight(2);
          noFill();
          rect(i*40, 0, 40, 40);
          var item = editorInventory[i];
          if(item === 1){
            fill(currentLevel.blockCol);
            noStroke();
            rect(i*40 + 5, 5, 30, 30);
          } else if(item.type === "button"){
            fill(currentLevel.channelColors[item.channel - 1]);
            noStroke();
            ellipse(i*40 + 20, 20, 25, 25);
          } else if(item.type === "door"){
            fill(currentLevel.channelColors[item.channel - 1]);
            noStroke();
            rect(i*40 + 5, 5, 30, 30);
          }
        }
        if(pickedObject !== null){
          stroke(255, 255, 0);
          strokeWeight(3);
          noFill();
          for(var i = 0; i < editorInventory.length; i++){
            if(editorInventory[i] === pickedObject){
              rect(i*40, 0, 40, 40);
            }
          }
        }
        if(mouseIsPressed && !mouseLeftCanvas && mouseY <= 40){
          for(var i=0; i<editorInventory.length; i++){
            if(mouseX >= i*40 && mouseX < (i+1)*40){
              pickedObject = editorInventory[i];
            }
          }
        }
        /*if(checkDeathCollision()){
          playing = false;
          currentLevel.scrolled = -120;
          for(var i=0; i<currentLevel.channels.length; i++){
            currentLevel.channels[i] = false;
          }
          for(var i=0; i<currentLevel.area.length; i++){
            for(var j=0; j<currentLevel.area[i].length; j++){
              var cell = currentLevel.area[i][j];
              if(cell.type === "button"){
                cell.remaining = cell.clicks;
              }
            }
          }
        }*/
        /*if(checkWin()){
          playing = false;
          println("You win!");
          // You win!
        }*/
      }


    }};

  // Get the canvas that ProcessingJS will use
  // var canvas = document.getElementById("mycanvas");  // Already defined above
  // Pass the function to ProcessingJS constructor
</script>

  <script>
  // Update the current level's `scrolled` value when the wheel is used over the canvas.
  // This keeps wheel handling local to the canvas and prevents the page from scrolling.
  (function(){
    canvas.addEventListener('wheel', function(e){
      // prevent the page from also scrolling
      e.preventDefault();

      var delta = e.deltaY;
      // normalize line/page modes to approximate pixels
      if(e.deltaMode === 1) delta *= 40; // lines -> pixels
      else if(e.deltaMode === 2) delta *= 400; // pages -> pixels

      // `currentLevel` is defined inside the Processing sketch; access it via the
      // global `processingInstance` created below.
      console.log('wheel delta:', delta, 'mode:', e.deltaMode);
      if(typeof processingInstance !== 'undefined' && processingInstance && processingInstance.currentLevel && typeof processingInstance.currentLevel.scrolled === 'number'){
          processingInstance.currentLevel.scrolled -= delta/5; // adjust scroll speed
          console.log('updated scrolled:', processingInstance.currentLevel.scrolled);
        } else {
          console.log('processingInstance or currentLevel not ready', !!processingInstance, !!(processingInstance && processingInstance.currentLevel));
        }
    }, {passive: false});
  })();
  </script>

  <script>
  var processingInstance = new Processing(canvas, programCode);
  
  // Download level string when Enter is pressed
  document.addEventListener('keydown', function(e){
    if(e.key === 'Enter'){
      if(typeof processingInstance !== 'undefined' && processingInstance.downloadLevelString){
        processingInstance.downloadLevelString();
      }
    }
  });
  </script>
</html>